
* Ob-sql-session
:PROPERTIES:
:header-args:elisp: :results raw
:END:

#+author: Philippe Estival pe@7d.nz
#+date : [2024-05-29 Wed]
License: GPL3

https://github.com/flintforge/ob-sql-session.el
# https://7d.nz/org-babel-sql-session


Surprisingly =org/ob-sql.el= does't provide a session
mode. Reason is every block is passed as a one
command-line shell execution along the connexion
arguments and closed at the end (see for instance
man:psql, option -c).

=ob-sql-mode.el= was proposed as an alternative.  It
relies on =sql-session= to open a client connection, then
performs a simple =sql-redirect= as execution of the sql
source block, before cleaning the prompt.  /ob-sql-mode/
is not a "mode" per se. Yet it's a starting point to
get sessions partially working over SQL.

But more intersting is this comment in comint:
file:/usr/local/share/emacs/29.3/lisp/comint.el.gz::3570

Which brings two remarks:

- =Sql-redirect= can perfectly handle many batches of
  commands at once, but it relies on
  =accept-process-output= which is not the best way to
  handle redirections through comint, and can sometimes
  get very clunky with bursts of outputs.

- Relying on the detection of the prompt should not be
  necessary as comint records where the last output began.

- Misdirected output happens when using
  =org-babel-execute:sql-mode= with several commands or
  longer execution times. =sql-redirect= can indeed accept
  multiple commands. The problem comes from properly
  handling =accept-process-output=.

The following has been tested on emacs 28, 29 and 30,
org-mode 9.6.28.

While you may have found it on github,
it's intended to be read and run on org-mode.

#+begin_src elisp
(setq debug-on-error t)
(use-package ob-sql-session)
#+end_src

#  #+begin_src elisp
#   (defun do-org-confirm-babel-evaluations (lang body)
#     (not
#      (or
#       (string= lang "emacs-lisp")
#       (string= lang "elisp")
#       (string= lang "sql-session"))))
#   (setq org-confirm-babel-evaluate 'do-org-confirm-babel-evaluations)
# #+end_src


  #+begin_src elisp
  (sql-set-product-feature 'sqlite :prompt-regexp "sqlite> ")
  (sql-set-product-feature 'sqlite :prompt-cont-regexp "")
  #+end_src

  #+RESULTS:

#+begin_src sql-session :engine sqlite :database test.db :results table

  drop table test;
  create table test(one varchar(10), two smallint);
  insert into test values('hello', 10);
  insert into test values('world', 20);
  select * from test;
  select format("sqlite %s",sqlite_version()), date(), time();
#+end_src

#+RESULTS:
| hello         |         10 |          |
| world         |         20 |          |
| sqlite 3.40.1 | 2024-05-30 | 13:12:30 |


What about running an in memory sqlite ?

#+begin_src patch
modified   lisp/progmodes/sql.el
@@ -5061,14 +5061,15 @@ sql-sqlite
   (interactive "P")
   (sql-product-interactive 'sqlite buffer))
 
-(defun sql-comint-sqlite (product options &optional buf-name)
+(defun sql-comint-sqlite (product &optional options buf-name)
   "Create comint buffer and connect to SQLite."
   ;; Put all parameters to the program (if defined) in a list and call
   ;; make-comint.
   (let ((params
          (append options
-                 (if (not (string= "" sql-database))
-                     `(,(expand-file-name sql-database))))))
+                 (if (and sql-database
+                         (not (string= "" sql-database)))
+                         `(,(expand-file-name sql-database))))))
     (sql-comint product params buf-name)))

#+end_src

#+begin_src sql-session :engine sqlite
  create table test(one varchar(10), two smallint);
  select format("sqlite %s",sqlite_version()), date(), time();

#+end_src

#+RESULTS:
: sqlite 3.40.1|2024-05-30|14:18:06


#+begin_src sql-session :engine sqlite :session "A"
  create table test(one varchar(10), two smallint);
  select format("sqlite %s",sqlite_version()), date(), time();
#+end_src

#+RESULTS:
: Parse error: table test already exists
:   create table test(one varchar(10), two smallint);
:                ^--- error here
: sqlite 3.40.1|2024-05-30|14:19:14



#+begin_src sql-session :engine postgres :dbuser dba :database test :dbserver localhost :dbpassword dba

  select inet_client_addr();
  select localtime(0);
  select current_date, current_time;
         
#+end_src

#+RESULTS:
: ::1
: 17:47:35
: 2024-05-30|17:47:35.317297+02



Here are the options to 
get an org-friendly results.
Exit the current sql process and evaluate this:
#+begin_src elisp

  (sql-set-product-feature 'postgres :prompt-regexp "SQL> ")
  (sql-set-product-feature 'postgres :prompt-cont-regexp "")
  (setq sql-postgres-options (list
            "--set=ON_ERROR_STOP=1"
            (concat "--set=PROMPT1="
              (sql-get-product-feature 'postgres :prompt-regexp ))
            (concat "--set=PROMPT2="
              (sql-get-product-feature 'postgres :prompt-cont-regexp ))
            "-q"
            "-P" "pager=off"
            "-P" "footer=off" "-A"
            "--tuples-onlmmy"
            ))

#+end_src

#+RESULTS:
| --set=ON_ERROR_STOP=1 | --set=PROMPT1=SQL> | --set=PROMPT2= | -q | -P | pager=off | -P | footer=off | -A | -t |

Default prompts regexp are 
: "^[-[:alnum:]_]*[-=][#>] "
=PROMPT2= is the continuation prompt,
displayed when a command spans over several line
indicating when the sql shell expects more
input on a newline.


* Session starts
:PROPERTIES:
:header-args:sql-session: :session "1" :engine postgres :dbuser dba :database test :dbserver localhost
:END:

#+begin_example
:PROPERTIES:
:header-args:sql-session: :session "1" :engine postgres :dbuser dba :database test :dbserver localhost
:END:
#+end_example
  
#+begin_src sql-session :results table

  select inet_client_addr(),inet_server_addr();
  select localtime(0),localtime(6);
  select current_date, current_time;;

#+end_src

#+RESULTS:
|        ::1 |                ::1 |
|   10:13:17 |    10:13:17.293031 |
| 2024-05-30 | 10:13:17.293676+02 |


** variables
#+name: test-sql-session    
#+begin_src sql-session :results output :var x="7" y="inet_client_addr()"
  select $x;
  select current_schema, $y;
  select current_date, current_time;       
#+end_src

#+RESULTS: test-sql-session
: 7
: public|::1
: 2024-05-30|16:10:48.100296+02



** Test against large output
#+begin_src sql-session
	drop  sequence serial;
	Create sequence serial start 1;
	select nextval('serial'),array(select generate_series(0, 200)) from generate_series(0, 250);
#+end_src
pass

** running tests
see [[info:ert#Running Tests in Batch Mode][ert#Running Tests in Batch Mode]]

** TODO
- Provide the password with [[file:/usr/share/emacs/28.2/lisp/env.el.gz::defmacro with-environment-variables][with-environment-variables]].
- some properties relative to the session (prompt-regex)
  or surprises happens when switching db
- close terminal when no session 

