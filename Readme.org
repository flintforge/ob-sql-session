* Ob-sql-session
:PROPERTIES:
:header-args:elisp: :results raw
:END:
#+author: Philippe Estival pe@7d.nz
#+date : [2024-05-29 Wed]
#+License: GPL3

https://github.com/flintforge/ob-sql-session.el
[[https://github.com/flintforge/ob-sql-session/actions][file:https://github.com/flintforge/ob-sql-session/actions/workflows/CI.yml/badge.svg]]
# https://7d.nz/org-babel-sql-session

** Orb babel functions for SQL, with session
=Org/ob-sql.el= does not provide a session mode because
source blocks are passed as a command-line execution
along the connexion arguments without any terminal (see
for instance man:psql, option -c).

=ob-sql-mode.el= was proposed as an alternative.  It
relies on =sql-session= to open a client connection, then
performs a simple =sql-redirect= as execution of the sql
source block, before cleaning the prompt.  /ob-sql-mode/
is not a "mode" per se. Yet it's a starting point to
get sessions partially working over SQL.

But more intersting is this comment in comint:
file:/usr/local/share/emacs/29.3/lisp/comint.el.gz::3570

Which brings two remarks:

- =Sql-redirect= can perfectly handle many batches of
  commands at once, but it relies on
  =accept-process-output= which is not the best way to
  handle redirections through comint, and sometimes get
  clunky when bursts of outputs occurs with improper
  synchronizations.

- As long as the output is not a stream, relying on the
  detection of the prompt should not be necessary as
  comint records where a last output began.

- Misdirected output happens when using
  =org-babel-execute:sql-mode= with several commands or
  longer execution times. =sql-redirect= can indeed accept
  multiple commands. The problem comes from properly
  handling =accept-process-output=.

The following has been tested on emacs 28, 29 and 30,
org-mode 9.6.28.


#+begin_src elisp
(use-package ob-sql-session)
#+end_src

#  #+begin_src elisp
#   (defun do-org-confirm-babel-evaluations (lang body)
#     (not
#      (or
#       (string= lang "emacs-lisp")
#       (string= lang "elisp")
#       (string= lang "sql-session"))))
#   (setq org-confirm-babel-evaluate 'do-org-confirm-babel-evaluations)
# #+end_src


  #+begin_src elisp
  (sql-set-product-feature 'sqlite :prompt-regexp "sqlite> ")
  (sql-set-product-feature 'sqlite :prompt-cont-regexp "   \.\.\.> ")
  #+end_src

	
sql.el has to be patched in order to run sqlite in memory
(ob-sqlite has no session support either an requires a database)

	#+begin_src sql-session :engine sqlite :results table :database test.db
.headers on
		create table test("x","y");
		insert into test values ("sqlite",sqlite_version());
		insert into test values (date(),time());
		select * from test;

#+end_src

#+begin_src sql-session :engine sqlite
	drop table test;
	create table test(one varchar(10), two int);
	-- create table test(one varchar(10), two int);
#+end_src


Here is a good test.
Drop takes times and the output get off track
if this is less than 0.3
[[file:ob-sql-session.el::(sleep-for ]]
(need to keep the buffer open then)
#+begin_src sql-session :engine sqlite :database test.db :results output
	drop table test;
	create table test(one varchar(10), two smallint);
	insert into test values('hello', 1);
	insert into test values('world', 2);
	select * from test;
	select format("sqlite %s",sqlite_version()), date(), time();

#+end_src

** in order to run sqlite in memory
=sql-database= can be /nil/ and no option given

#+begin_src patch
modified   lisp/progmodes/sql.el
@@ -5061,14 +5061,15 @@ sql-sqlite
   (interactive "P")
   (sql-product-interactive 'sqlite buffer))

-(defun sql-comint-sqlite (product options &optional buf-name)
+(defun sql-comint-sqlite (product &optional options buf-name)
   "Create comint buffer and connect to SQLite."
   ;; Put all parameters to the program (if defined) in a list and call
   ;; make-comint.
   (let ((params
          (append options
-                 (if (not (string= "" sql-database))
-                     `(,(expand-file-name sql-database))))))
+                 (if (and sql-database
+                         (not (string= "" sql-database)))
+                         `(,(expand-file-name sql-database))))))
     (sql-comint product params buf-name)))

#+end_src

#+begin_src sql-session :engine sqlite

	create table test(an int, two char);
	SELECT *
  FROM sqlite_schema;
	select format("sqlite %s",sqlite_version()), date(), time();

#+end_src


Same session
#+begin_src sql-session :engine sqlite :session A
	create table test(an int, two char);
	select format("sqlite %s",sqlite_version()), date(), time();
#+end_src


** Test on postgres
                   ðŸ¡‡
: (setenv "DBUSER"    )
#+begin_src sql-session :engine postgres :dbuser (getenv "DBUSER") dba :database test :dbserver localhost

  select inet_client_addr();
	select localtime(0);
	select current_date, current_time;

#+end_src

#+RESULTS:
: ::1
: 22:51:30
: 2024-05-31|22:51:29.935886+02

** Formatting results
Requires the prompts to be filtered
#+begin_src elisp

  (sql-set-product-feature 'postgres :prompt-regexp "SQL> ")
  (sql-set-product-feature 'postgres :prompt-cont-regexp "")
  (setq sql-postgres-options (list
            "--set=ON_ERROR_STOP=1"
            (concat "--set=PROMPT1="
              (sql-get-product-feature 'postgres :prompt-regexp ))
            (concat "--set=PROMPT2="
              (sql-get-product-feature 'postgres :prompt-cont-regexp ))
            "-q"
            "-P" "pager=off"
            "-P" "footer=off" "-A"
            "--tuples-onlmmy"
            ))

#+end_src

#+RESULTS:
| --set=ON_ERROR_STOP=1 | --set=PROMPT1=SQL> | --set=PROMPT2= | -q | -P | pager=off | -P | footer=off | -A | -t |

Default prompts regexp are
: "^[-[:alnum:]_]*[-=][#>] "
=PROMPT2= is the continuation prompt,
displayed when a command spans over several line
indicating when the sql shell expects more
input on a newline.

** Variables
#+name: test-sql-session
#+begin_src sql-session :engine sqlite :var x="3.0"
  select 1/$x;
#+end_src

#+RESULTS: test-sql-session
: 0.333333333333333


** Test against large output

#+begin_src sql-session :engine postgres :dbuser dba :database test :dbserver localhost
	drop sequence serial;
	Create sequence serial start 1;
	select nextval('serial'),array(select generate_series(0, 200)) from generate_series(0, 250);
#+end_src


pass

** TODO >
- [ ] Provide password with [[file:/usr/share/emacs/28.2/lisp/env.el.gz::defmacro with-environment-variables][with-environment-variables]]
- [ ] properties relative to the session (clean-output-regex)
- [ ] testing
	
